"""update_states

Revision ID: c7648694325f
Revises: f1f20ae58def
Create Date: 2024-12-16 16:05:21.356662

"""

from alembic import op
import sqlalchemy as sa
from sqlalchemy.orm import Session
from enum import Enum as PyEnum
from nlds_processors.monitor.monitor_models import SubRecord

# revision identifiers, used by Alembic.
revision = "c7648694325f"
down_revision = "f1f20ae58def"
branch_labels = None
depends_on = None

class OldState(PyEnum):
    # Generic states
    INITIALISING = -1
    ROUTING = 0
    COMPLETE = 100
    FAILED = 101
    # PUT workflow states
    SPLITTING = 1
    INDEXING = 2
    CATALOG_PUTTING = 3
    TRANSFER_PUTTING = 4
    CATALOG_ROLLBACK = 5
    # GET workflow states
    CATALOG_GETTING = 10
    ARCHIVE_GETTING = 11
    TRANSFER_GETTING = 12
    # ARCHIVE_PUT workflow states
    ARCHIVE_INIT = 20
    CATALOG_ARCHIVE_AGGREGATING = 21
    ARCHIVE_PUTTING = 22
    CATALOG_ARCHIVE_UPDATING = 23
    # Shared ARCHIVE states
    CATALOG_ARCHIVE_ROLLBACK = 40

class NewState(PyEnum):
    # Generic states
    INITIALISING = -1
    ROUTING = 0
    # PUT workflow states
    SPLITTING = 1
    INDEXING = 2
    CATALOG_PUTTING = 3
    TRANSFER_PUTTING = 4
    # GET workflow states
    CATALOG_GETTING = 10
    ARCHIVE_GETTING = 11
    TRANSFER_GETTING = 12
    TRANSFER_INIT = 13
    # ARCHIVE_PUT workflow states
    ARCHIVE_INIT = 20
    ARCHIVE_PUTTING = 21
    ARCHIVE_PREPARING = 22
    # CATALOG manipulation workflow states
    CATALOG_DELETING = 30
    CATALOG_UPDATING = 31
    CATALOG_ARCHIVE_UPDATING = 32
    CATALOG_REMOVING = 33
    # Complete states
    COMPLETE = 100
    FAILED = 101
    COMPLETE_WITH_ERRORS = 102
    COMPLETE_WITH_WARNINGS = 103
    # Initial state for searching for sub-states
    SEARCHING = 1000

# A map from the old values of State to the new ones, including doubling up on 
# the catalog_restoring
state_map = {
    OldState.INITIALISING: NewState.INITIALISING,
    OldState.ROUTING: NewState.ROUTING,
    OldState.COMPLETE: NewState.COMPLETE,
    OldState.FAILED: NewState.FAILED,
    OldState.SPLITTING: NewState.SPLITTING,
    OldState.INDEXING: NewState.INDEXING,
    OldState.CATALOG_PUTTING: NewState.CATALOG_PUTTING,
    OldState.TRANSFER_PUTTING: NewState.TRANSFER_PUTTING,
    OldState.CATALOG_ROLLBACK: NewState.CATALOG_REMOVING,
    OldState.CATALOG_GETTING: NewState.CATALOG_GETTING,
    OldState.ARCHIVE_GETTING: NewState.ARCHIVE_GETTING,
    OldState.TRANSFER_GETTING: NewState.TRANSFER_GETTING,
    OldState.ARCHIVE_INIT: NewState.ARCHIVE_INIT,
    OldState.ARCHIVE_PUTTING: NewState.ARCHIVE_PUTTING,
    OldState.CATALOG_ARCHIVE_UPDATING: NewState.CATALOG_ARCHIVE_UPDATING,
}

# Create ENUM types, one for old, one for new, one for temp
old_enum = sa.Enum(OldState, name='state')
new_enum = sa.Enum(NewState, name='state')

def upgrade(engine_name: str) -> None:
    globals()["upgrade_%s" % engine_name]()


def downgrade(engine_name: str) -> None:
    globals()["downgrade_%s" % engine_name]()


def upgrade_catalog() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade_catalog() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def upgrade_monitor() -> None:
    with op.batch_alter_table("sub_record") as bop:
        # Change the column type from enum to string 
        bop.alter_column("state", existing_server_default=None,
                         existing_nullable=False, type_=sa.String(length=32))

    # Get the session to update the database values with 
    session = Session(bind=op.get_bind())
    # Loop through each of the states in the map from old states to new states. 
    for old_state, new_state in state_map.items():
        sub_records = session.query(SubRecord).filter(
            SubRecord.state.name == old_state.name
        ).all()
        # Assing the state to the new value
        for sr in sub_records:
            sr.state = new_state
    
    # Remove the old enum type and create the new one
    old_enum.drop(op.get_bind(), checkfirst=False)
    new_enum.create(op.get_bind(), checkfirst=False)

    with op.batch_alter_table("sub_record") as bop:
        # Change the column type back to enum, but use the new one 
        bop.alter_column("state", existing_server_default=None,
                         existing_nullable=False, type_=new_enum,
                         postgresql_using='state::text::state')
    # Commit the changes to the db.  
    session.commit()


def downgrade_monitor() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table("sub_record") as bop:
        # Change the column type from enum to string 
        bop.alter_column("state", existing_server_default=None,
                         existing_nullable=False, type_=sa.String(length=32))
    op.alter_column

    # Get the session to update the database values with 
    session = Session(bind=op.get_bind())
    # Loop through each of the states in the map from old states to new states. 
    for old_state, new_state in state_map.items():
        sub_records = session.query(SubRecord).filter(
            SubRecord.state.name == new_state.name
        ).all()
        # Assing the state to the old value. 
        for sr in sub_records:
            sr.state = old_state

    # Remove the old enum type and create the new one
    new_enum.drop(op.get_bind(), checkfirst=False)
    old_enum.create(op.get_bind(), checkfirst=False)
            
    # Change the column type to the new ENUM 
    with op.batch_alter_table("sub_record") as bop:
        # Change the column type back to the old enum  
        bop.alter_column("state", existing_server_default=None,
                         existing_nullable=False, type_=old_enum, 
                         postgresql_using='state::text::state')
        
    # Commit the changes to the db.  
    session.commit()
    # ### end Alembic commands ###
